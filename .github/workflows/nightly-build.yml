name: Nightly Build - MSSQL 2022 Windows Container

on:
  schedule:
    # Run at 3 AM UTC daily
    - cron: '0 3 * * *'
  push:
    branches:
      - main
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/mssql-server-windows-developer

jobs:
  build:
    runs-on: windows-latest
    permissions:
      contents: write
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install and start containerd
        shell: pwsh
        run: |
          Write-Host "Installing containerd..."

          # Download and install containerd
          $containerdVersion = "2.2.1"
          $arch = "amd64"
          $url = "https://github.com/containerd/containerd/releases/download/v$containerdVersion/containerd-$containerdVersion-windows-$arch.tar.gz"

          Write-Host "Downloading containerd v$containerdVersion..."
          curl.exe -fSLO $url
          tar.exe xvf "containerd-$containerdVersion-windows-$arch.tar.gz"

          # Install to Program Files
          $containerdPath = "$env:ProgramFiles\containerd"
          New-Item -Path $containerdPath -ItemType Directory -Force | Out-Null
          Copy-Item -Path ".\bin\*" -Destination $containerdPath -Recurse -Force

          # Add to PATH for this session
          $env:Path = "$containerdPath;$env:Path"

          # Create default config
          & "$containerdPath\containerd.exe" config default | Out-File "$containerdPath\config.toml" -Encoding ascii

          # Register and start containerd as a Windows service
          Write-Host "Registering containerd as a Windows service..."
          & "$containerdPath\containerd.exe" --register-service --config "$containerdPath\config.toml"
          Start-Service containerd

          # Wait for containerd pipe to be ready
          Write-Host "Waiting for containerd to be ready..."
          $pipePath = "\\.\pipe\containerd-containerd"
          $maxAttempts = 30
          $attempt = 0
          while ($attempt -lt $maxAttempts) {
            Start-Sleep -Seconds 2
            $attempt++
            $pipeExists = Test-Path $pipePath
            if ($pipeExists) {
              Write-Host "containerd is ready! (pipe exists: $pipePath)"
              break
            }
            Write-Host "Attempt $attempt/$maxAttempts - Waiting for containerd pipe..."
          }

          if (-not (Test-Path $pipePath)) {
            Write-Host "containerd service status:"
            Get-Service containerd | Format-List *
            Write-Error "containerd failed to start - pipe not found at $pipePath"
            exit 1
          }

          Write-Host "containerd installed and running"

      - name: Install BuildKit
        shell: pwsh
        run: |
          Write-Host "Installing BuildKit..."

          # Get latest BuildKit version
          $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/moby/buildkit/releases/latest" -UseBasicParsing
          $version = $releases.tag_name
          $arch = "amd64"

          Write-Host "Downloading BuildKit $version..."
          curl.exe -fSLO "https://github.com/moby/buildkit/releases/download/$version/buildkit-$version.windows-$arch.tar.gz"
          tar.exe xvf "buildkit-$version.windows-$arch.tar.gz"

          # Install to Program Files
          $buildkitPath = "$env:ProgramFiles\buildkit"
          New-Item -Path $buildkitPath -ItemType Directory -Force | Out-Null
          Copy-Item -Path ".\bin\*" -Destination $buildkitPath -Force

          # Add to PATH for this session
          $env:Path = "$buildkitPath;$env:Path"

          Write-Host "BuildKit installed to $buildkitPath"

      - name: Install CNI plugins
        shell: pwsh
        run: |
          Write-Host "Installing CNI plugins..."

          $cniVersion = "0.3.3"
          $cniBinDir = "$env:ProgramFiles\containerd\cni\bin"
          $cniConfDir = "$env:ProgramFiles\containerd\cni\conf"

          New-Item -Path $cniBinDir -ItemType Directory -Force | Out-Null
          New-Item -Path $cniConfDir -ItemType Directory -Force | Out-Null

          # Download CNI plugins
          $cniUrl = "https://github.com/microsoft/windows-container-networking/releases/download/v$cniVersion/windows-container-networking-cni-amd64-v$cniVersion.zip"
          curl.exe -fSLO $cniUrl
          tar.exe xvf "windows-container-networking-cni-amd64-v$cniVersion.zip" -C $cniBinDir

          # Get NAT network info for CNI config
          $natNetwork = Get-HnsNetwork | Where-Object { $_.Name -eq "nat" }
          if ($natNetwork) {
            $gateway = $natNetwork.Subnets[0].GatewayAddress
            $subnet = $natNetwork.Subnets[0].AddressPrefix

            $cniConfig = @"
          {
            "cniVersion": "0.2.0",
            "name": "nat",
            "type": "nat",
            "master": "Ethernet",
            "ipam": {
              "subnet": "$subnet",
              "routes": [
                {
                  "gateway": "$gateway"
                }
              ]
            },
            "capabilities": {
              "portMappings": true,
              "dns": true
            }
          }
          "@
            $cniConfig | Out-File "$cniConfDir\0-containerd-nat.conf" -Encoding ascii
            Write-Host "CNI configured with subnet: $subnet, gateway: $gateway"
          } else {
            Write-Host "Warning: NAT network not found, CNI may not work properly"
          }

      - name: Start BuildKit daemon
        shell: pwsh
        run: |
          Write-Host "Starting BuildKit daemon..."

          $buildkitPath = "$env:ProgramFiles\buildkit"
          $cniConfPath = "$env:ProgramFiles\containerd\cni\conf\0-containerd-nat.conf"
          $cniBinDir = "$env:ProgramFiles\containerd\cni\bin"

          # Start buildkitd with CNI configuration and explicit address
          $buildkitdArgs = @(
            "--addr", "npipe:////./pipe/buildkitd",
            "--containerd-cni-config-path=$cniConfPath",
            "--containerd-cni-binary-dir=$cniBinDir"
          )

          Write-Host "Starting buildkitd with args: $($buildkitdArgs -join ' ')"
          Start-Process -FilePath "$buildkitPath\buildkitd.exe" -ArgumentList $buildkitdArgs -WindowStyle Hidden -RedirectStandardOutput "buildkitd.log" -RedirectStandardError "buildkitd.err"

          # Wait for buildkitd to be ready
          Write-Host "Waiting for BuildKit to be ready..."
          $pipePath = "\\.\pipe\buildkitd"
          $maxAttempts = 30
          $attempt = 0
          while ($attempt -lt $maxAttempts) {
            Start-Sleep -Seconds 2
            $attempt++

            # Check if pipe exists
            $pipeExists = Test-Path $pipePath
            Write-Host "Attempt $attempt/$maxAttempts - Pipe exists: $pipeExists"

            if ($pipeExists) {
              $env:Path = "$buildkitPath;$env:Path"
              $result = & "$buildkitPath\buildctl.exe" --addr "npipe:////./pipe/buildkitd" debug info 2>&1
              if ($LASTEXITCODE -eq 0) {
                Write-Host "BuildKit is ready!"
                Write-Host $result
                break
              } else {
                Write-Host "buildctl returned error: $result"
              }
            }
          }

          if ($attempt -eq $maxAttempts) {
            Write-Host "BuildKit daemon logs:"
            if (Test-Path "buildkitd.log") { Get-Content "buildkitd.log" }
            if (Test-Path "buildkitd.err") { Get-Content "buildkitd.err" }
            Write-Error "BuildKit failed to start"
            exit 1
          }

          Write-Host "BuildKit daemon started successfully on npipe:////./pipe/buildkitd"

      - name: Install Docker Buildx plugin
        shell: pwsh
        run: |
          Write-Host "Installing Docker Buildx plugin..."

          # Get latest buildx version
          $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/docker/buildx/releases/latest" -UseBasicParsing
          $version = $releases.tag_name
          Write-Host "Latest buildx version: $version"

          # Download buildx binary for Windows
          $downloadUrl = "https://github.com/docker/buildx/releases/download/$version/buildx-$version.windows-amd64.exe"
          Write-Host "Downloading from: $downloadUrl"
          curl.exe -fSLO $downloadUrl

          # Create Docker CLI plugins directory
          $pluginsDir = "$env:USERPROFILE\.docker\cli-plugins"
          New-Item -Path $pluginsDir -ItemType Directory -Force | Out-Null

          # Install buildx plugin
          Move-Item -Path "buildx-$version.windows-amd64.exe" -Destination "$pluginsDir\docker-buildx.exe" -Force

          # Verify installation
          Write-Host "Verifying buildx installation..."
          docker buildx version

          Write-Host "Docker Buildx plugin installed successfully"

      - name: Set up Docker Buildx with native BuildKit
        shell: pwsh
        run: |
          Write-Host "Creating buildx builder with native BuildKit..."

          # Check if buildkitd is still running
          $buildkitdProcess = Get-Process -Name "buildkitd" -ErrorAction SilentlyContinue
          if ($buildkitdProcess) {
            Write-Host "buildkitd process is running (PID: $($buildkitdProcess.Id))"
          } else {
            Write-Host "WARNING: buildkitd process not found!"
            Write-Host "Checking buildkitd logs..."
            if (Test-Path "buildkitd.log") {
              Write-Host "=== buildkitd.log ==="
              Get-Content "buildkitd.log"
            }
            if (Test-Path "buildkitd.err") {
              Write-Host "=== buildkitd.err ==="
              Get-Content "buildkitd.err"
            }
          }

          # List all named pipes to debug
          Write-Host "Listing buildkit-related pipes..."
          Get-ChildItem //./pipe/ | Where-Object { $_.Name -like "*buildkit*" -or $_.Name -like "*containerd*" } | ForEach-Object { Write-Host "  Pipe: $($_.Name)" }

          # Verify buildkitd pipe is accessible
          $pipePath = "\\.\pipe\buildkitd"
          if (-not (Test-Path $pipePath)) {
            Write-Host "BuildKit pipe not found at $pipePath"
            Write-Host "Attempting to restart buildkitd..."

            $buildkitPath = "$env:ProgramFiles\buildkit"
            $cniConfPath = "$env:ProgramFiles\containerd\cni\conf\0-containerd-nat.conf"
            $cniBinDir = "$env:ProgramFiles\containerd\cni\bin"

            # Kill any existing buildkitd
            Stop-Process -Name "buildkitd" -Force -ErrorAction SilentlyContinue

            # Restart buildkitd
            $buildkitdArgs = @(
              "--addr", "npipe:////./pipe/buildkitd",
              "--containerd-cni-config-path=$cniConfPath",
              "--containerd-cni-binary-dir=$cniBinDir"
            )
            Start-Process -FilePath "$buildkitPath\buildkitd.exe" -ArgumentList $buildkitdArgs -WindowStyle Hidden

            # Wait for pipe
            $maxAttempts = 15
            for ($i = 1; $i -le $maxAttempts; $i++) {
              Start-Sleep -Seconds 2
              if (Test-Path $pipePath) {
                Write-Host "BuildKit pipe now available after restart"
                break
              }
              Write-Host "Waiting for pipe... attempt $i/$maxAttempts"
            }

            if (-not (Test-Path $pipePath)) {
              Write-Error "BuildKit pipe still not found after restart"
              exit 1
            }
          }
          Write-Host "BuildKit pipe verified at $pipePath"

          # Create a buildx builder that uses the local buildkitd
          $buildkitAddr = "npipe:////./pipe/buildkitd"
          Write-Host "Creating buildx builder with address: $buildkitAddr"

          docker buildx create --name windows-builder --driver remote $buildkitAddr --use
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to create buildx builder"
            exit 1
          }

          Write-Host "Builder created, verifying connection..."

          # List builders to verify
          docker buildx ls

          Write-Host "Buildx configured with native Windows BuildKit"

      - name: Generate build metadata
        id: meta
        shell: pwsh
        run: |
          $date = Get-Date -Format "yyyyMMdd"
          $shortSha = "${{ github.sha }}".Substring(0, 7)

          # Generate tags
          $tags = @(
            "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest",
            "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:2022"
          )

          # For non-main branch pushes, add branch tag
          if ("${{ github.ref }}" -ne "refs/heads/main" -and "${{ github.event_name }}" -eq "push") {
            $branch = "${{ github.ref_name }}" -replace '[^a-zA-Z0-9]', '-'
            $tags += "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$branch"
          }

          $tagsString = $tags -join "`n"

          # Output for GitHub Actions
          echo "date=$date" >> $env:GITHUB_OUTPUT
          echo "short_sha=$shortSha" >> $env:GITHUB_OUTPUT

          # Handle multiline output
          echo "tags<<EOF" >> $env:GITHUB_OUTPUT
          echo $tagsString >> $env:GITHUB_OUTPUT
          echo "EOF" >> $env:GITHUB_OUTPUT

          Write-Host "Build date: $date"
          Write-Host "Tags to be applied:"
          $tags | ForEach-Object { Write-Host "  - $_" }

      - name: Download SQL Server 2022 media
        shell: pwsh
        run: |
          Write-Host "Downloading SQL Server 2022 Developer Edition..."
          & .\scripts\download-sqlserver.ps1 -OutputPath ".\sql-media" -TempPath ".\temp-download"

      - name: Verify SQL Server media
        shell: pwsh
        run: |
          $setupPath = Get-ChildItem -Path ".\sql-media" -Filter "setup.exe" -Recurse | Select-Object -First 1
          if (-not $setupPath) {
            Write-Error "setup.exe not found in sql-media directory"
            exit 1
          }
          Write-Host "SQL Server media verified: $($setupPath.FullName)"

          Write-Host ""
          Write-Host "Media directory contents:"
          Get-ChildItem -Path ".\sql-media" -Depth 1 | ForEach-Object {
            Write-Host "  $($_.Name)"
          }

      - name: Compute SQL media checksum
        id: checksum
        shell: pwsh
        run: |
          # Load checksum function
          . "${{ github.workspace }}\scripts\lib\Get-FolderChecksum.ps1"

          $checksum = Get-FolderChecksum -Path ".\sql-media" -Algorithm SHA256
          Write-Host "Computed checksum: $checksum"

          $shortChecksum = $checksum.Substring(0, 8)
          Write-Host "Short checksum: $shortChecksum"

          echo "hash=$checksum" >> $env:GITHUB_OUTPUT
          echo "short_hash=$shortChecksum" >> $env:GITHUB_OUTPUT
          echo "tag_name=sql-media-checksum/$shortChecksum" >> $env:GITHUB_OUTPUT

      - name: Check for existing checksum tag
        id: tag_check
        shell: pwsh
        run: |
          $tagName = "${{ steps.checksum.outputs.tag_name }}"
          Write-Host "Looking for tag: $tagName"

          # Fetch tags from remote
          git fetch --tags --quiet 2>$null

          # Check if exact tag exists
          $tagExists = git tag -l $tagName

          if ($tagExists) {
            Write-Host "Tag already exists: $tagName"
            Write-Host "SQL media has not changed - build can be skipped"
            echo "exists=true" >> $env:GITHUB_OUTPUT
            echo "skip_build=true" >> $env:GITHUB_OUTPUT
          }
          else {
            Write-Host "Tag does not exist: $tagName"
            Write-Host "SQL media has changed or this is the first run - build required"
            echo "exists=false" >> $env:GITHUB_OUTPUT
            echo "skip_build=false" >> $env:GITHUB_OUTPUT
          }

      - name: Log in to Container Registry
        if: steps.tag_check.outputs.skip_build != 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push Docker image
        if: steps.tag_check.outputs.skip_build != 'true'
        shell: pwsh
        env:
          DOCKER_BUILDKIT: 1
        run: |
          Write-Host "Building and pushing Docker image with zstd compression..."

          $tags = "${{ steps.meta.outputs.tags }}" -split "`n" | Where-Object { $_.Trim() }
          $tagArgs = ($tags | ForEach-Object { "--tag", $_.Trim() }) -join " "

          Write-Host "Tags to be applied:"
          $tags | ForEach-Object { Write-Host "  - $($_.Trim())" }

          $buildCmd = @(
            "docker", "buildx", "build",
            "--output", "type=image,oci-mediatypes=true,compression=zstd,compression-level=3,push=true",
            "--cache-from", "type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache",
            "--cache-to", "type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max"
          )

          # Add tags
          foreach ($tag in $tags) {
            $trimmedTag = $tag.Trim()
            if ($trimmedTag) {
              $buildCmd += "--tag"
              $buildCmd += $trimmedTag
            }
          }

          # Add context
          $buildCmd += "."

          Write-Host "Executing: $($buildCmd -join ' ')"
          & $buildCmd[0] $buildCmd[1..($buildCmd.Length - 1)]

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Docker buildx build failed"
            exit 1
          }

          Write-Host "Docker build and push completed successfully"

      - name: Create checksum tag
        if: steps.tag_check.outputs.skip_build != 'true'
        shell: pwsh
        run: |
          $tagName = "${{ steps.checksum.outputs.tag_name }}"
          $fullHash = "${{ steps.checksum.outputs.hash }}"

          Write-Host "Creating tag: $tagName"

          # Configure git for tagging
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create annotated tag with full hash in message
          git tag -a $tagName -m "SQL media checksum: $fullHash"

          # Push the tag
          git push origin $tagName

          Write-Host "Tag created and pushed successfully: $tagName"

      - name: Report build skipped
        if: steps.tag_check.outputs.skip_build == 'true'
        shell: pwsh
        run: |
          Write-Host "=============================================="
          Write-Host "BUILD SKIPPED - SQL Media unchanged"
          Write-Host "=============================================="
          Write-Host ""
          Write-Host "Checksum: ${{ steps.checksum.outputs.hash }}"
          Write-Host "Tag: ${{ steps.checksum.outputs.tag_name }}"
          Write-Host ""
          Write-Host "The SQL Server media has not changed since the last build."
          Write-Host "Docker image build and push were skipped to save resources."

      - name: Generate build summary
        shell: pwsh
        run: |
          $skipped = "${{ steps.tag_check.outputs.skip_build }}" -eq "true"

          if ($skipped) {
            $summary = @"
          ## MSSQL 2022 Windows Container Build Summary

          **Build Date:** ${{ steps.meta.outputs.date }}
          **Commit:** ${{ github.sha }}
          **Trigger:** ${{ github.event_name }}
          **Status:** :fast_forward: SKIPPED (SQL media unchanged)

          ### SQL Media Checksum
          - **Checksum:** ``${{ steps.checksum.outputs.hash }}``
          - **Tag:** ``${{ steps.checksum.outputs.tag_name }}``

          The SQL Server media files have not changed since the last successful build.
          Docker image build and push were skipped.
          "@
          }
          else {
            $summary = @"
          ## MSSQL 2022 Windows Container Build Summary

          **Build Date:** ${{ steps.meta.outputs.date }}
          **Commit:** ${{ github.sha }}
          **Trigger:** ${{ github.event_name }}
          **Status:** :white_check_mark: SUCCESS

          ### SQL Media Checksum
          - **Checksum:** ``${{ steps.checksum.outputs.hash }}``
          - **Tag:** ``${{ steps.checksum.outputs.tag_name }}``

          ### Published Images

          ``````
          ${{ steps.meta.outputs.tags }}
          ``````

          ### Usage

          ``````powershell
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

          docker run -d ``
            -e ACCEPT_EULA=Y ``
            -e SA_PASSWORD=YourStrong!Password123 ``
            -p 1433:1433 ``
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          ``````

          ### Verify Connection

          ``````powershell
          sqlcmd -S localhost -U sa -P YourStrong!Password123 -Q "SELECT @@VERSION"
          ``````
          "@
          }

          $summary | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8

      - name: Cleanup
        if: always()
        shell: pwsh
        run: |
          Write-Host "Cleaning up..."

          # Remove SQL media (already deleted during build, but ensure cleanup)
          if (Test-Path ".\sql-media") {
            Remove-Item -Path ".\sql-media" -Recurse -Force -ErrorAction SilentlyContinue
          }

          if (Test-Path ".\temp-download") {
            Remove-Item -Path ".\temp-download" -Recurse -Force -ErrorAction SilentlyContinue
          }

          Write-Host "Cleanup completed"
